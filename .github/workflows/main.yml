name: Discord Bot

on:
  push:
    branches: [ main ]
  workflow_dispatch:
  schedule:
    - cron: '*/30 * * * *'  # 30分ごとにチェック（UTC）

jobs:
  run-bot:
    runs-on: ubuntu-latest
    
    # 同じコミットに対して同時に複数のワークフローが実行されないようにする
    concurrency: 
      group: bot-${{ github.ref }}
      cancel-in-progress: true
    
    steps:
    - uses: actions/checkout@v3
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Set timezone to Japan
      run: |
        sudo timedatectl set-timezone Asia/Tokyo
        date
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.13'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Setup database directory
      run: |
        mkdir -p data backup
        chmod 755 data backup
    
    - name: Pull latest database
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git pull origin main || true
        
        # バックアップを作成
        if [ -f "bot.db" ]; then
          echo "既存のデータベースをバックアップします"
          cp bot.db bot.db.backup.$(date +%Y%m%d_%H%M%S)
        fi
        
        # コンフリクト解消
        if [ -f "bot.db" ]; then
          echo "✅ 既存のbot.db を使用します"
        else
          echo "⚠️ bot.dbが見つかりません"
          echo "🔄 GitHubから取得を試みます..."
          git pull origin main || echo "⚠️ GitHubからの取得に失敗しました"
          
          if [ -f "bot.db" ]; then
            echo "✅ GitHubからbot.dbを取得しました"
          else
            echo "⚠️ GitHubにもbot.dbがありません"
            echo "🔄 バックアップから復元を試みます..."
            if [ -d "backup" ] && [ "$(ls -1 backup/*.db 2>/dev/null | wc -l)" -gt 0 ]; then
              LATEST_BACKUP=$(ls -1t backup/*.db 2>/dev/null | head -n 1)
              cp "$LATEST_BACKUP" bot.db
              echo "✅ バックアップから復元しました: $LATEST_BACKUP"
            else
              echo "❌ バックアップもありません"
              if [ ! -f "bot.db" ]; then
                echo "📝 新規に空のデータベースを作成します（既存ファイルはありません）"
                touch bot.db
              else
                echo "✅ 既存のbot.dbを保護します（上書しません）"
              fi
            fi
          fi
        fi
    
    - name: Check if database exists
      run: |
        # データベースの状態を確認
        if [ -f "bot.db" ]; then
          echo "既存のデータベースサイズ: $(wc -c < bot.db) bytes"
          if [ -s "bot.db" ]; then
            echo "✅ 既存のデータベースを使用します（データあり）"
            
            # データベースにデータがあるか確認
            sqlite3 bot.db "SELECT COUNT(*) FROM thoughts;" > /tmp/db_count.txt 2>/dev/null || echo "0" > /tmp/db_count.txt
            DB_COUNT=$(cat /tmp/db_count.txt)
            echo "📊 データベースの投稿数: $DB_COUNT"
            
            if [ "$DB_COUNT" -gt 0 ]; then
              echo "✅ データベースにデータが存在します。既存データを保護します。"
              # 既存データを保護（上書きしない）
              if [ -f "bot.db" ]; then
                echo "⚠️ bot.db は無視します（既存データを保護）"
                # rm -f bot.db  # ← 削除：5分ごとにbot.dbを消さないようにする
              fi
            else
              echo "⚠️ データベースは空です"
              # バックアップから自動復元を試みる
              echo "🔄 バックアップからの自動復元を試みます..."
              if [ -d "backup" ] && [ "$(ls -1 backup/*.db 2>/dev/null | wc -l)" -gt 0 ]; then
                LATEST_BACKUP=$(ls -1t backup/*.db 2>/dev/null | head -n 1)
                echo "📁 最新のバックアップ: $LATEST_BACKUP"
                cp "$LATEST_BACKUP" bot.db
                echo "✅ バックアップから復元しました"
                
                # 復元後の確認
                RESTORED_COUNT=$(sqlite3 bot.db "SELECT COUNT(*) FROM thoughts;" 2>/dev/null || echo "0")
                echo "📊 復元後の投稿数: $RESTORED_COUNT"
                if [ "$RESTORED_COUNT" -gt 0 ]; then
                  echo "✅ データ復元に成功しました"
                else
                  echo "⚠️ バックアップも空でした"
                fi
              else
                echo "⚠️ 利用可能なバックアップがありません"
              fi
            fi
          else
            echo "⚠️ 既存のデータベースは空です"
            # 上記の復元ロジックで処理されるため、ここでは何もしない
          fi
        else
          echo "⚠️ データベースが存在しません"
          echo "🔄 GitHubから取得を試みます..."
          git pull origin main || echo "⚠️ GitHubからの取得に失敗しました"
          
          if [ -f "bot.db" ]; then
            echo "✅ GitHubからデータベースを取得しました"
          else
            echo "⚠️ GitHubにもデータベースがありません"
            echo "🔄 バックアップから復元を試みます..."
            if [ -d "backup" ] && [ "$(ls -1 backup/*.db 2>/dev/null | wc -l)" -gt 0 ]; then
              LATEST_BACKUP=$(ls -1t backup/*.db 2>/dev/null | head -n 1)
              cp "$LATEST_BACKUP" bot.db
              echo "✅ バックアップから復元しました: $LATEST_BACKUP"
            else
              echo "❌ バックアップもありません"
              if [ ! -f "bot.db" ]; then
                echo "📝 新規に空のデータベースを作成します（既存ファイルはありません）"
                touch bot.db
              else
                echo "✅ 既存のbot.dbを保護します（上書しません）"
              fi
            fi
          fi
        fi
        
        # 最終的なデータベース状態を確認
        if [ -f "bot.db" ]; then
          echo "📊 最終データベースサイズ: $(wc -c < bot.db) bytes"
          if [ -s "bot.db" ]; then
            sqlite3 bot.db "SELECT COUNT(*) FROM thoughts;" > /tmp/final_count.txt 2>/dev/null || echo "0" > /tmp/final_count.txt
            FINAL_COUNT=$(cat /tmp/final_count.txt)
            echo "📊 最終投稿数: $FINAL_COUNT"
          else
            echo "⚠️ 最終データベースは空です"
          fi
        fi
    
    - name: Check if bot is running
      id: check_bot
      env:
        DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
        ALLOWED_CHANNEL_IDS: ${{ secrets.ALLOWED_CHANNEL_ID }}
      run: |
        # 既存の実行中のワークフローをチェック
        RUNNING_JOBS=$(curl -s -H "Authorization: token ${{ github.token }}" \
          "https://api.github.com/repos/${{ github.repository }}/actions/runs?status=in_progress" | \
          jq -r '.workflow_runs[] | select(.id != ${{ github.run_id }}) | .id')
        
        if [ -z "$RUNNING_JOBS" ]; then
          echo "ボットが実行されていないため、起動します"
          echo "RUN_BOT=true" >> $GITHUB_ENV
        else
          echo "ボットは既に実行中です"
          echo "RUN_BOT=false" >> $GITHUB_ENV
        fi
    
    - name: Run bot
      if: env.RUN_BOT == 'true'
      env:
        DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
        ALLOWED_CHANNEL_IDS: ${{ secrets.ALLOWED_CHANNEL_ID }}
      run: |
        # ボット起動時にデータベースパスを指定
        export DB_PATH="bot.db"
        
        # 既存のプロセスを終了
        pkill -f "python.*bot.py" || true
        
        # ボットを起動
        nohup python bot.py > bot.log 2>&1 &
        echo $! > bot.pid
        
        # 起動を待つ
        sleep 10
        
        # ログを表示
        cat bot.log
        
        # プロセスが実行中か確認
        if ! ps -p $(cat bot.pid) > /dev/null; then
          echo "ボットの起動に失敗しました"
          cat bot.log
          exit 1
        fi
        
        echo "ボットが正常に起動しました"
        
        # 無限ループで待機
        while true; do
          # ボットがまだ実行中か確認
          if ! ps -p $(cat bot.pid) > /dev/null; then
            echo "ボットが終了しました。再起動します..."
            # 再起動
            export DB_PATH="bot.db"
            nohup python bot.py > bot.log 2>&1 &
            echo $! > bot.pid
            sleep 10
          fi
          # 1分ごとにチェック
          sleep 60
        done
    
    - name: Create automatic backup
      run: |
        if [ -f "bot.db" ]; then
          echo "🔄 自動バックアップを作成します..."
          mkdir -p backup
          
          # バックアップファイル名にタイムスタンプを付けて保存
          BACKUP_FILE="backup/auto_backup_$(date '+%Y%m%d_%H%M%S').db"
          cp bot.db "$BACKUP_FILE"
          
          echo "✅ バックアップを作成しました: $BACKUP_FILE"
          echo "📊 バックアップサイズ: $(wc -c < "$BACKUP_FILE") bytes"
          
          # バックアップファイルの数を確認（無制限に保持）
          BACKUP_COUNT=$(ls -1 backup/auto_backup_*.db 2>/dev/null | wc -l)
          echo "📁 現在のバックアップ数: $BACKUP_COUNT（無制限）"
        else
          echo "ℹ️ データベースファイルが存在しないため、バックアップを作成しません"
        fi
    
    - name: Commit database changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # バックアップファイルの変更をチェック
        BACKUP_CHANGED=false
        if [ -d "backup" ]; then
          for backup_file in backup/auto_backup_*.db; do
            if [ -f "$backup_file" ] && ! git diff --quiet "$backup_file"; then
              BACKUP_CHANGED=true
              break
            fi
          done
        fi
        
        # バックアップファイルが変更されている場合のみコミット
        if [ "$BACKUP_CHANGED" = true ]; then
          echo "📝 バックアップファイルをGitHubに保存します..."
          git add backup/auto_backup_*.db
          
          # コミットをリトライ
          for i in {1..3}; do
            if git commit -m "📁 Update backup files - $(date '+%Y-%m-%d %H:%M:%S')"; then
              echo "✅ バックアップファイルをコミットしました (試行 $i)"
              break
            else
              echo "⚠️ コミット失敗、リトライします (試行 $i/3)"
              git pull --rebase origin main || true
              sleep 5
            fi
          done
          
          # プッシュをリトライ
          for i in {1..3}; do
            if git push origin main; then
              echo "✅ バックアップファイルをプッシュしました (試行 $i)"
              break
            else
              echo "⚠️ プッシュ失敗、リトライします (試行 $i/3)"
              git pull --rebase origin main || true
              sleep 5
            fi
          done
        else
          echo "ℹ️ バックアップファイルに変更はありません"
        fi
    
    - name: Show logs
      if: always()
      run: |
        if [ -f bot.log ]; then
          echo "=== 最終ログ ==="
          echo "=== DEBUGログを含む全ログ ==="
          grep -E "(DEBUG|ERROR|WARNING)" bot.log || echo "DEBUGログが見つかりません"
          echo "=== 最終50行 ==="
          tail -n 50 bot.log
        fi
        if [ -f bot.db ]; then
          echo "=== データベース情報 ==="
          ls -la bot.db
          sqlite3 bot.db "SELECT COUNT(*) FROM thoughts;" || echo "データベースが存在しません"
          echo "=== 最近の投稿 ==="
          sqlite3 bot.db "SELECT id, is_anonymous, is_private, created_at FROM thoughts ORDER BY created_at DESC LIMIT 5;" || echo "投稿データが取得できません"
        fi
        
        if [ -d "backup" ]; then
          echo "=== バックアップ情報 ==="
          echo "📁 バックアップファイル一覧:"
          ls -la backup/auto_backup_*.db 2>/dev/null || echo "バックアップファイルがありません"
          BACKUP_COUNT=$(ls -1 backup/auto_backup_*.db 2>/dev/null | wc -l)
          echo "📊 バックアップ数: $BACKUP_COUNT（無制限）"
        fi
